using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _454_ab_language_Csharp
{
    class Language
    {
        
        // given a rule, and position in input string, permute if rule applies then return new string
        private string  produceNewString(string stringToChange, int whichRule, int currentchar){

	string newString = "";

	// depending on rule, use specified production rule
	switch (whichRule){
	case 0: // a -> ab
		if (stringToChange[currentchar] == 'a') newString = stringToChange + "b";
		break;
	case 1: // b -> ba
		if (stringToChange[currentchar] == 'b') newString = stringToChange + 'a';
		break;
	case 2: // a-> aa
		if (stringToChange[currentchar] == 'a') newString = stringToChange + 'a';
		break;
	case 3: // b -> bb
		if (stringToChange[currentchar] == 'b') newString = stringToChange + 'b';
		break;
	}
	return newString;
}

        // write to file all strings generated by production rules up to length n, using either 2 or 4 rules as specified
        public void createDict()
        {


            // how long is longest bit string
            Console.WriteLine("Bit string length : ");
            int numChars = Convert.ToInt32(Console.ReadLine());

            // how many rules to use
            Console.WriteLine("Use all rules? enter 2 or 4: ");
            int numRules = Convert.ToInt32(Console.ReadLine());


            string path = @"C sharp dictionary.txt";

            // create text file
            if (!File.Exists(path))
            {
                File.WriteAllText(path, "\xef\xbb\xbf");

                
            }

            // keep track of current generation of strings
            List<string> prevGen = new List<string> { "a", "b" };

            // check if ok to make new strings
            while (prevGen[0].Length <= numChars)
            {

                List<string> newGen = new List<string> { }; // hold each new generation

  
                // record strings from old generation because must be valid
                for (int i = 0; i < prevGen.Count; i++)
                    File.AppendAllText(path, prevGen[i] + ',');

                // for each ancestor, permute each character via the production rules
                for (int currentAncestor = 0; currentAncestor < prevGen.Count; currentAncestor++)
                {

                    // for each character in the current ancestor use each rule
                    for (int currentChar = 0; currentChar < prevGen[currentAncestor].Length; currentChar++)
                    {

                        // for each rule, check if a new string is produced, if so add to new generation
                        for (int currentRule = 0; currentRule < numRules; currentRule++)
                        {

                            // generate new string as result of current rule
                            string child = produceNewString(prevGen[currentAncestor], currentRule, currentChar);

                            // if the new child is not in the current newGen, add to newGen
                            if (child.Length > 1)
                            {

                                // nothin in generation so add
                                if (newGen.Count == 0) newGen.Add(child);

                                // child already there
                                else if (newGen.Contains(child))
                                    continue;

                                // not already in new generation so add!
                                else
                                    newGen.Add(child);
                            }

                        }
                    }
                }

                // update old generation
                prevGen = newGen;
            }
        }


        static int Main(string[] args)
        {
            Language A = new Language();
            A.createDict();
            return 0;
        }
    }
}
